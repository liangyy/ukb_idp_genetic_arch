'''
This script converts a list of models generated by run_gw_lasso.R 
(which is in thin format) into a wide table, which is similar to 
the output of run_gw_ridge.py. 
The output is in parquet format.
'''

import pandas as pd

def load_model_as_wide(fn):
    df = pd.read_csv(fn, sep='\t', compression='gzip')
    df_snp = df[['snpid', 'REF', 'ALT', 'CHR']].drop_duplicates(inplace=False)
    phenos = list(set(list(df.phenotype)))
    for pheno in phenos:
        df_snp = pd.merge(
            df_snp, 
            df[ df.phenotype == pheno ].drop(
                columns='phenotype').rename(
                columns={'weight': pheno}
            ), 
            how='left', on=['snpid', 'REF', 'ALT', 'CHR']
        )
    df_snp.reset_index(drop=True, inplace=True)
    df_snp.fillna(0, inplace=True)
    return df_snp

def left_join_with_main(df_main, df_new):
    if df_main is None:
        return df_new
    tmp = pd.merge(df_main, df_new, how='outer', on=['snpid', 'REF', 'ALT', 'CHR'])
    tmp.fillna(0, inplace=True)
    return tmp

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(prog='post_process_training.py', description='''
        Perform post-process on the models trained by 
        run_gw_lasso.R --mode training. The output is 
        the table of weights in wide format (parquet table). 
        Need export PYTHONPATH=path-to-misc-tools/pyutil.
    ''')
    parser.add_argument('--model_list', help='''
        The list of input models (file path).
    ''')
    parser.add_argument('--rename_yaml', default=None, help='''
        (Optional) Sometimes, we may want to rename the phenotype.
        Specify the rename rule in the yaml (curr_name: new_name).
    ''')
    parser.add_argument('--output', help='''
        Output.
    ''')
    args = parser.parse_args()
 
    import logging, time, sys, os
    # configing util
    logging.basicConfig(
        level = logging.INFO, 
        stream = sys.stderr, 
        format = '%(asctime)s  %(message)s',
        datefmt = '%Y-%m-%d %I:%M:%S %p'
    )
    
    from tqdm import tqdm
    from pyutil import load_list, intersection
    
    if args.rename_yaml is not None:
        from pyutil import read_yaml
        rename_dict = read_yaml(args.rename_yaml)
    else:
        rename_dict = None
    
    out = None
    model_files = load_list(args.model_list)
    logging.info('There are {} model files to load.'.format(len(model_files)))
    for model_path in tqdm(model_files):
        model = load_model_as_wide(model_path)
        if out is not None:
            common_cols = intersection(model.columns[4:], out.columns[4:])
            if len(common_cols) > 0:
                raise ValueError('Duplicated columns: {}'.format(', '.join(common_cols)))
        out = left_join_with_main(out, model)
    
    # clean rename dict so that it only contains keys occurring in out
    rename_dict_new = {}
    for k in rename_dict.keys():
        if k in out.columns:
            rename_dict_new[k] = rename_dict[k]
    rename_dict = rename_dict_new
    
    out.rename(columns=rename_dict, inplace=True)
    out.rename(columns={'REF': 'a0', 'ALT': 'a1', 'CHR': 'chr'}, inplace=True)
 
    out.to_parquet(args.output)
    
    
